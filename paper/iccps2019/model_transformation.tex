%
%
%%%%%%%%%%%%%%%%
%

\section{Model Transformation}
\seclabel{transformation}
%\vspace{-0.5em}
%
\subsection{Representation of Hybrid System}
Hybrid automata~\cite{alur1995algorithmic} are a modeling formalism popularly used to model hybrid systems which include both continuous dynamics and discrete state transitions. A hybrid automaton is essentially a finite state machine extended with a set of real-valued variables evolving continuously over intervals of real-time~\cite{alur1995algorithmic}\footnote{In this paper, we only consider \emph{deterministic} systems, where the system produces the same output for a given input. Note the contrast with {\em stochastic} systems in which one or more elements of the system have randomness associated with them; for example, the value of some system parameter may be extracted from a probability distribution. As a result, the stochastic system may yield different outputs for a given input.}.
%
%%
The main structure of a hybrid automaton $\AutomatonH$ includes the following components.
%
%
%, where the parameters representing arbitrary values which do not change during one system execution~\cite{frehse2008counterexample, schwarz2011modelling}.
% In our approach, we present hybrid automata using MathWorks Simulink/StateÂƒflow toolbox
%
%
%
 %Analogous to hybrid automata, a Stateflow diagram is a finite state machine extended with different types of variables, and its structures includes the following components.

%In a Stateflow diagram, a designer can specify different data types including continuous state variables, parameters, inputs, and outputs of the model, and define the discrete structures similar to a hybrid automata. The Stateflow includes the folli
%
\begin{itemize}[leftmargin= 2em]
%\begin{inparaenum}[(a)]
%
\item $\Varset$: the finite set of $n$ continuous, real-valued variables; we have $\Varset = \X \cup \P$, where $\X \in \Realn$ is the set of $n$ state variables and $\P\in\Realp$ is the set of $p$ parameters. Moreover, $\Varset$ is the disjoint of the set of input variables $\I$ and the set of output variables $\O$.
\item $\Locset$: the finite set of discrete modes. For each mode $\mode \in \Locset$, $\mode.\inveg \subseteq \Real^{n+p}$ denotes the invariant of mode $\mode$, and $\mode.\floweg \subseteq \Realn$ describes the continuous dynamics governed by a set of different equations. $\Q \deq \Locset \times \Realn$ is the state space.
%(a set of algebraic constraints)
\item $\Transset$: the finite set of transitions between modes.
%
Each transition is a tuple $\tau \deq \tuple{\src, \dst, \guard, \reset}$, where $\src$ is a source mode and $\dst$ is a target mode that may be taken when a guard condition $\guard$ is satisfied, and the post-state is updated by an update map $\reset$.
%
%
%\item $\Trajectoryset$: a finite set of continuous trajectory models the valuations of state variables over an interval of real time $[0, T]$. Let $\val{x}_t$ be the valuations of variable $x$ at time points $t$, $\forall t \in [0, T]$, $\forall x \in \X$, $\exists m \in \Locset$, a trajectory $\gamma \in \Trajectoryset$ is a mapping function $\gamma: [0, T] \rightarrow \val{\X}$ such that:
%\begin{itemize}
%\item $\val{x}_t = \val{x}_0 + \int_{\delta = 0}^{t} m.\floweg(x) d\delta$, and %where $\Delta_0$ is a valuation of variable $x$ at $t = 0$
%\item $\val{x}_t \models m.\inveg$ for all $t \in [0, T]$.
%%
%\end{itemize}
%
\item $\Initset$ is an initial condition, and $\Initset \subseteq \Q$.
%\end{inparaenum}
\end{itemize}
%
We use the dot (.) notation to refer to different components of tuples \eg $\AutomatonH.\Transset$ refers to the transitions of automaton $\AutomatonH$ and $\tau.\guard$ refers to the guard of a transition $\tau$. %Such notation is also abused in the proposed transformation language.
%
We note that the \emph{model transformation language} proposed in this paper transforms a hybrid automaton based on modifying these components in a generic manner. The transformation tool of \toolreaffirm can take a HATL transformation script and translate it into an equivalent script that performs a model transformation for different modeling framework of hybrid automata including a continuous-time Stateflow chart.
%

\vspace{0.5em}
\noindent
{\bf Continuous-time Stateflow Chart.}
%In this paper, we represent a hybrid automata as a \emph{continuous-time} Stateflow chart, which is a commercial modeling language for hybrid systems integrated within MathWorks Simulink.
%%
%Continuous-time Stateflow chart\footnote{In this paper, we focus only on continuous-time Stateflow diagram that does not include hierarchical states.} supplies methods for engineers to quickly model as well as efficiently refine, test, and generate code for hybrid systems. In a Stateflow diagram, a designer can specify different data types including continuous state variables, parameters, inputs, and outputs of the model, and define the discrete structures similar to a PHIOA.
%%
%
In this paper, we represent hybrid automata using \emph{continuous-time} Stateflow chart, which is a standard commercial modeling language for hybrid systems integrated within MathWorks Simulink.
%
Continuous-time Stateflow chart\footnote{In this paper, we focus only on continuous-time Stateflow diagram that does not include hierarchical states.} supplies methods for engineers to quickly model as well as efficiently refine, test, and generate code for hybrid automata.
%
The syntactic components of a continuous-time Stateflow chart are described similar to a hybrid automaton where a mode is a \emph{state} associated with different types of actions including a) \emph{entry} action executed when entering the state, b) \emph{exit} executed when exiting the state, and c) \emph{during} action demonstrates the continuous-time evolution of the variables (\ie $\floweg$ dynamics) when no transition is enabled. A variable can be specified as \emph{parameter}, \emph{input}, \emph{output}, and \emph{local variable}. A Stateflow diagram is deterministic since its transition is urgent and executed with priorities.
%
Intuitively, a transition in a Stateflow chart is triggered as soon as the transition guard condition is satisfied, while a hybrid automaton can stay at the current mode as long as its invariant still holds.  To overcome this gap, a recent work proposed in~\cite{bak2017hybrid} provides an equivalent translation for both classes of deterministic and non-deterministic hybrid automata to Stateflow diagrams. Other significant research have been done to translate back and forth between hybrid automata and Simulink/Stateflow models~\cite{alur2008symbolic,manamcheri2011step,minopoli2016sl2sx}.
%\noindent
%{\bf Hybrid Automata.}

\subsection{Hybrid Automata Transformation Language}
In our approach, the partial model of the system, which satisfies
functional but not necessarily resiliency requirements is originally
modeled in the form of hybrid automata. The model transformation that
is at the core of the \toolreaffirm tool will then attempt to modify
the modes, flows, and switching logic of the automata, by applying
user-defined resiliency patterns.

In order to specify resiliency patterns for hybrid automata, we
introduce a new language for model transformation called HATL (Hybrid
Automata Transformation Language). The goal of HATL is to allow a
designer to repair an original model in a programmatic fashion. HATL
scripts abstract model implementation details so engineers do not need
to learn the intricacies of an individual framework. A key use of HATL
is to write generic scripts that applicable to many models, promoting
resilience scripts which are reusable.

A script written in HATL is a sequence of \emph{statements} that
specify the changes over the structure of given hybrid
automata. HATL's syntax and semantics are designed to make it
intuitive to anyone who is familar with imperative languages. HATL
includes \emph{loop} statements that iterate over sets of objects,
such as modes or transitions of a model. It uses \emph{dot references}
to index into structures to obtain data fields or to call
object-specific methods. \emph{Assignments} are mutable, and scoped
within statement blocks. Functions and methods can have variable
numbers of arguments which are eagerly evaluated.

The model transformation tool built in \toolreaffirm takes a
resiliency pattern in the form of a HATL script. HATL will translate
each of these statements into operations on continous-time Stateflow
models. An example HATL script (used in the first case study) can be
seen in figure \figref{examplecode}.\footnote{While Stateflow chart requires that the default transitions should be explicitly specified for exclusive (OR) states at every level of a hierarchy, other modeling frameworks of hybrid automata often describe it separately in a configuration file.}.
%

\begin{figure}[!t]%frame=none,
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, numbers=none]

# model is already with the model specified
# by the script arguments

model_copy = copyModel(model) # make a model copy
model.addParam("theta") # add new parameter theta

formode m = model.modes {
		m_copy = model.addState(m)
		m.replace(copy.flow,"ngps","nenc")
		model.addTransition(m,m_copy,"abs(ngps-nenc)>theta")
}

fortran t = model_copy.transitions {
		# get source and destination modes of transition t
		src = t.source
		dst = t.destination
		# retrieve copies of source and destination modes
		src_copy = model.getCopyState(src)
		dst_copy = model.getCopyState(dst)
		model.addTransition(src_copy,dst_copy,t.guard)
}
# end of the transformation
\end{lstlisting}
\caption{An example of a resiliency pattern written as a HATL script for the ACC system.}%
\figlabel{examplecode}%
	%\vspace{-0.5em}%
\end{figure}

\subsection{Implementation}

Our current implementation dynamically interprets HATL scripts in
Python and translates them into Stateflow model transformations via
the MATLAB Engine. Our interpreter checks argument values at runtime
to ensure only valid transformed models are produced. If a malformed
program statement is detected, HATL will throw a verbose error message
and roll back any changes it has applied already before
exiting. Additionally, these error messages are reported in terms of
generic HATL models, so an engineer writing a resilience pattern does
not need to worry about the underlying implementation.

Currently HATL provides enough programming abstraction to express
concise model transformations that function as valid resiliency
patterns: examples of these scripts can be seen in our case
studies. There is room for future improvement, such as adding language
constructs like object hierarchy or type checking. Expanding HATL's
backend to include more modeling frameworks besides Simulink/Stateflow
would be useful as well.
