%
%
%%%%%%%%%%%%%%%%
%

\section{Model Transformation}
\seclabel{transformation}
%\vspace{-0.5em}
% 
\subsection{Representation of Hybrid System}
Hybrid automata~\cite{alur1995algorithmic} are a modeling formalism popularly used to model hybrid systems which include both continuous dynamics and discrete state transitions. A hybrid automaton is essentially a finite state machine extended with a set of real-valued variables evolving continuously over intervals of real-time~\cite{alur1995algorithmic}.\footnote{In this paper, we only consider \emph{deterministic} systems, where the system produces the same output for a given input. Note the contrast with {\em stochastic} systems in which one or more elements of the system have randomness associated with them; for example, the value of some system parameter may be extracted from a probability distribution. As a result, the stochastic system may yield different outputs for a given input.} 
%
%%
The main structure of a hybrid automaton $\AutomatonH$ includes the following components.
%
%
%, where the parameters representing arbitrary values which do not change during one system execution~\cite{frehse2008counterexample, schwarz2011modelling}.
% In our approach, we present hybrid automata using MathWorks Simulink/Stateflow toolbox
%
%
%
 %Analogous to hybrid automata, a Stateflow diagram is a finite state machine extended with different types of variables, and its structures includes the following components.

%In a Stateflow diagram, a designer can specify different data types including continuous state variables, parameters, inputs, and outputs of the model, and define the discrete structures similar to a hybrid automata. The Stateflow includes the folli 
%
\begin{itemize}[leftmargin= 2em]
%\begin{inparaenum}[(a)]
%
\item $\Varset$: the finite set of $n$ continuous, real-valued variables; we have $\Varset = \X \cup \P$, where $\X \in \Realn$ is the set of $n$ state variables and $\P\in\Realp$ is the set of $p$ parameters. Moreover, $\Varset$ is the disjoint of the set of input variables $\I$ and the set of output variables $\O$.
\item $\Locset$: the finite set of discrete modes. For each mode $\mode \in \Locset$, $\mode.\inveg \subseteq \Real^{n+p}$ denotes the invariant of mode $\mode$, and $\mode.\floweg \subseteq \Realn$ describes the continuous dynamics governed by a set of different equations. $\Q \deq \Locset \times \Realn$ is the state space.
%(a set of algebraic constraints)
\item $\Transset$: the finite set of transitions between modes.
%
Each transition is a tuple $\tau \deq \tuple{\src, \dst, \guard, \reset}$, where $\src$ is a source mode and $\dst$ is a target mode that may be taken when a guard condition $\guard$ is satisfied, and the post-state is updated by an update map $\reset$. 
%
%
%\item $\Trajectoryset$: a finite set of continuous trajectory models the valuations of state variables over an interval of real time $[0, T]$. Let $\val{x}_t$ be the valuations of variable $x$ at time points $t$, $\forall t \in [0, T]$, $\forall x \in \X$, $\exists m \in \Locset$, a trajectory $\gamma \in \Trajectoryset$ is a mapping function $\gamma: [0, T] \rightarrow \val{\X}$ such that:
%\begin{itemize}
%\item $\val{x}_t = \val{x}_0 + \int_{\delta = 0}^{t} m.\floweg(x) d\delta$, and %where $\Delta_0$ is a valuation of variable $x$ at $t = 0$
%\item $\val{x}_t \models m.\inveg$ for all $t \in [0, T]$.
%%
%\end{itemize}
%
\item $\Initset$ is an initial condition, and $\Initset \subseteq \Q$.
%\end{inparaenum}
\end{itemize}
%
We use the dot (.) notation to refer to different components of tuples \eg $\AutomatonH.\Transset$ refers to the transitions of automaton $\AutomatonH$ and $\tau.\guard$ refers to the guard of a transition $\tau$. %Such notation is also abused in the proposed transformation language.
%
We note that the \emph{model transformation language} proposed in this paper transforms a hybrid automaton based on modifying these components in a generic manner. The transformation tool of \toolreaffirm can this transformation script and translate it into an equivalent script that performs a model transformation for different modeling framework of hybrid automata such as a continuous-time Stateflow chart.
%

\vspace{0.5em}
\noindent
{\bf Continuous-time Stateflow Chart.}
%In this paper, we represent a hybrid automata as a \emph{continuous-time} Stateflow chart, which is a commercial modeling language for hybrid systems integrated within MathWorks Simulink.
%%
%Continuous-time Stateflow chart\footnote{In this paper, we focus only on continuous-time Stateflow diagram that does not include hierarchical states.} supplies methods for engineers to quickly model as well as efficiently refine, test, and generate code for hybrid systems. In a Stateflow diagram, a designer can specify different data types including continuous state variables, parameters, inputs, and outputs of the model, and define the discrete structures similar to a PHIOA.
%%
%
In this paper, we represent hybrid automata using \emph{continuous-time} Stateflow chart, which is a standard commercial modeling language for hybrid systems integrated within MathWorks Simulink.
%
Continuous-time Stateflow chart\footnote{In this paper, we focus only on continuous-time Stateflow diagram that does not include hierarchical states.} supplies methods for engineers to quickly model as well as efficiently refine, test, and generate code for hybrid automata.
%
The syntactic components of a continuous-time Stateflow chart are described similar to a hybrid automaton where a mode is a \emph{state} associated with different types of actions including a) \emph{entry} action executed when entering the state, b) \emph{exit} executed when exiting the state, and c) \emph{during} action demonstrates the continuous-time evolution of the variables (\ie $\floweg$ dynamics) when no transition is enabled. A variable can be specified as \emph{parameter}, \emph{input}, \emph{output}, and \emph{local variable}. A Stateflow diagram is deterministic since its transition is urgent and executed with priorities.
%
Intuitively, a transition in a Stateflow chart is triggered as soon as the transition guard condition is satisfied, while a hybrid automaton can stay at the current mode as long as its invariant still holds.  To overcome this gap, a recent work proposed in~\cite{bak2017hybrid} provides an equivalent translation for both classes of deterministic and non-deterministic hybrid automata to Stateflow diagrams. Other significant research have been done to translate back and forth between hybrid automata and Simulink/Stateflow models~\cite{alur2008symbolic,manamcheri2011step,minopoli2016sl2sx}.
%\noindent
%{\bf Hybrid Automata.}

\subsection{Hybrid Automata Transformation Language}
In our approach, the partial model of the system, which satisfies functional but not necessarily resiliency requirements is originally modeled in the form of hybrid automata. The model transformation that is at the core of \toolreaffirm tool will then attempt to add resilience modules to the system and modify switching logic between modes of the automata, by applying resilience patterns. 
%
%The resilience patterns can be either model-specific or generic, and need to be specified over strucuture of 
%
%We treat modes of hybrid automata as legacy components that the synthesizer will not modify. 
%
In order to specify resilient patterns for hybrid automata, we introduce a new transformation language called HATL (Hybrid Automata Transformation Language). The goal of HATL is to allow a designer to repair an original model in a programmable fashion. A script written in HATL is a sequence of \emph{statements} that specify the changes over the structure of given hybrid automata. There are three types of statements in HATL including
\begin{inparaenum}[(a)]
\item the \emph{loop} statement that iterates over the modes and transitions of a hybrid automaton,
\item the \emph{function call} statement that represents basic \emph{transformation rule} implemented as in a standard library for HATL. A function call statement may or may not have arguments. Several examples of such a basic function call is \emph{addMode}() (\ie generating a new empty mode), or \emph{addTransition}($m$, $m'$, $g$) (\ie creating a transition from mode $m$ to $m'$ with a guard condition $g$).
\item The \emph{assignment} statement sets a value (possibly returned by a function call) to a variable.
\end{inparaenum}
%

%\figref{examplecode} shows an example of a HATL script that specifies a transformation from the original ACC model shown in~\figref{original} to the parametrized model shown in~\figref{updated}. 
%
%In this script, we first create a copy of the original model. Next, we iterate over each mode of the model by calling the \emph{formode loop}, make a copy with replacing the variable $\ngps$ by $\nenc$, and then add a new transition from the original mode to the copied mode with a new guard condition. This guard condition is a constraint specified over the difference between $\ngps$ by $\nenc$ and a new parameter $\theta$, which is added into the model using a function call \emph{addParam}. 
%%
%%Finally, we need to copy all transitions between original modes (stored in a copied version of an original model) and assign them to a corresponding duplicated modes in a modified version.
%%
%%
%Then, we need to copy all transitions of the original model and properly assign them into the modified version. This process is achieved by iterating over each transition of the copy of the original model, retrieve the copies of the source and destination modes of the transition, then create a new transition between these corresponding duplicated modes with the same guard condition of the original transition.


%that iterates over each mode of an original hybrid automaton and then replace the variable $\ngps$ by the variable $\nenc$ in the flow dynamics.
%\figref{examplecode} shows an example of a loop statement that iterates over each mode of an original hybrid automaton and then replace the variable $\ngps$ by the variable $\nenc$ in the flow dynamics.
%

%\begin{figure}[!t]%frame=none,
%\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, numbers=none]
%model_copy = copyModel(model) # make a model copy 
	%
%# start a transformation  
%addParam(model,"theta") # add new parameter theta
	%
%formode m = model.modes {
		%m_copy = addState(model,m)
		%replace(m_copy.flow,"ngps","nenc")
		%addTransition(model,m,m_copy,"abs(ngps-nenc)>theta")
%}
%
%fortran t = model_copy.trans {
		%# get source and destination modes of transition t
		%src = t.source	
		%dst = t.destination 
		%# retrieve copies of source and destination modes 
		%src_copy = getCopyState(model,src)  
		%dst_copy = getCopyState(model,dst) 
		%addTransition(model,src_copy,dst_copy,t.guard)
%}
%# end of the transformation
%\end{lstlisting}
%\caption{An example of a resilient pattern written as a HATL script for the ACC system.}%
%\figlabel{examplecode}%
	%%\vspace{-0.5em}%
%\end{figure}
%

The model transformation tool built in \toolreaffirm takes a resilient pattern written as HATL script, parses it to an intermediate representation, which is a set of data structures encoding the syntax of a hybrid automaton in Python. As we represent hybrid automata as continuous-time Stateflow charts,
%
The HATL script then will be translated to a MATLAB script that performs a modification to the Stateflow chart through its API (Application Programming Interface). As an example, \figref{translatecode} describes the translated MATLAB script of the HATL script shown in \figref{examplecode}. The translation to MATLAB is straightforward except that the iteration over each transition in MATLAB should neglect the \emph{default transition}\footnote{While Stateflow chart requires that the default transitions should be explicitly specified for exclusive (OR) states at every level of a hierarchy, other modeling frameworks of hybrid automata often describe it separately in a configuration file.}.  
%
\begin{figure}[!t]%
\begin{lstlisting}[basicstyle=\ttfamily\footnotesize, numbers=none]
root = sfroot;
diagram = root.find('-isa','Simulink.BlockDiagram');
model = model.find('-isa', 'Stateflow.Chart');
model_copy = copyModel(model);

addParam(model,"theta")

modes = getStates(model);
for i = 1 : length(modes)
	m = modes(i);
	m_copy = addState(model,m);
	m_copy.Label = strrep(m_copy.Label,"ngps","nenc");
	addTransition(model,m,m_copy,"abs(ngps-nenc)>theta");
end

trans = getTransitions(model_copy);
for i = 1 : length(trans)
	t = trans(i);
	if notDefaultTransition(t)
		src = t.Source;
		dst = t.Destination;
		src_copy = getCopyState(model,src)
		dst_copy = getCopyState(model,dst)
		addTransition(model,src_copy,dst_copy,t.LabelString)
	end
end
\end{lstlisting}
\caption{A translated MATLAB script for the HATL script shown in \figref{examplecode}.}%
\figlabel{translatecode}%
	%\vspace{-0.5em}%
\end{figure}
%
\subsection{Implementation}